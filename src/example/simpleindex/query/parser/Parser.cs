// Generated by TinyPG v1.3 available at www.codeproject.com

using System;
using System.Collections.Generic;

namespace bsharptree.example.simpleindex.query.parser
{
    #region Parser

    public partial class Parser 
    {
        private Scanner scanner;
        private ParseTree tree;
        
        public Parser(Scanner scanner)
        {
            this.scanner = scanner;
        }

        public ParseTree Parse(string input)
        {
            tree = new ParseTree();
            return Parse(input, tree);
        }

        public ParseTree Parse(string input, ParseTree tree)
        {
            scanner.Init(input);

            this.tree = tree;
            ParseStart(tree);
            tree.Skipped = scanner.Skipped;

            return tree;
        }

        private void ParseStart(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Start), "Start");
            parent.Nodes.Add(node);


            
            tok = scanner.LookAhead(TokenType.OPERATOR);
            while (tok.Type == TokenType.OPERATOR)
            {
                tok = scanner.Scan(TokenType.OPERATOR);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.OPERATOR) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OPERATOR.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }
            tok = scanner.LookAhead(TokenType.OPERATOR);
            }

            
            tok = scanner.LookAhead(TokenType.OPERATOR, TokenType.MUSTPREFIX, TokenType.MUSTNOTPREFIX, TokenType.TERM, TokenType.QUOTE, TokenType.BROPEN);
            while (tok.Type == TokenType.OPERATOR
                || tok.Type == TokenType.MUSTPREFIX
                || tok.Type == TokenType.MUSTNOTPREFIX
                || tok.Type == TokenType.TERM
                || tok.Type == TokenType.QUOTE
                || tok.Type == TokenType.BROPEN)
            {
                ParseExpression(node);
            tok = scanner.LookAhead(TokenType.OPERATOR, TokenType.MUSTPREFIX, TokenType.MUSTNOTPREFIX, TokenType.TERM, TokenType.QUOTE, TokenType.BROPEN);
            }

            
            tok = scanner.Scan(TokenType.EOF);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOF) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOF.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseExpression(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Expression), "Expression");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.OPERATOR, TokenType.MUSTPREFIX, TokenType.MUSTNOTPREFIX, TokenType.TERM, TokenType.QUOTE, TokenType.BROPEN);
            while (tok.Type == TokenType.OPERATOR
                || tok.Type == TokenType.MUSTPREFIX
                || tok.Type == TokenType.MUSTNOTPREFIX
                || tok.Type == TokenType.TERM
                || tok.Type == TokenType.QUOTE
                || tok.Type == TokenType.BROPEN)
            {

                
                tok = scanner.LookAhead(TokenType.OPERATOR);
                while (tok.Type == TokenType.OPERATOR)
                {
                    tok = scanner.Scan(TokenType.OPERATOR);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.OPERATOR) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OPERATOR.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                tok = scanner.LookAhead(TokenType.OPERATOR);
                }

                
                tok = scanner.LookAhead(TokenType.MUSTPREFIX, TokenType.MUSTNOTPREFIX, TokenType.TERM, TokenType.QUOTE, TokenType.BROPEN);
                switch (tok.Type)
                {
                    case TokenType.MUSTPREFIX:
                        ParseMustClause(node);
                        break;
                    case TokenType.MUSTNOTPREFIX:
                        ParseMustNotClause(node);
                        break;
                    case TokenType.TERM:
                    case TokenType.QUOTE:
                    case TokenType.BROPEN:
                        ParseClause(node);
                        break;
                    default:
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                        break;
                }

                
                tok = scanner.LookAhead(TokenType.OPERATOR);
                while (tok.Type == TokenType.OPERATOR)
                {
                    tok = scanner.Scan(TokenType.OPERATOR);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.OPERATOR) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OPERATOR.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                tok = scanner.LookAhead(TokenType.OPERATOR);
                }
            tok = scanner.LookAhead(TokenType.OPERATOR, TokenType.MUSTPREFIX, TokenType.MUSTNOTPREFIX, TokenType.TERM, TokenType.QUOTE, TokenType.BROPEN);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseMustClause(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.MustClause), "MustClause");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.MUSTPREFIX);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.MUSTPREFIX) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MUSTPREFIX.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.TERM, TokenType.QUOTE, TokenType.BROPEN);
            switch (tok.Type)
            {
                case TokenType.TERM:
                case TokenType.QUOTE:
                    ParseTerm(node);
                    break;
                case TokenType.BROPEN:
                    ParseSubClause(node);
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseMustNotClause(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.MustNotClause), "MustNotClause");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.MUSTNOTPREFIX);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.MUSTNOTPREFIX) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MUSTNOTPREFIX.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.TERM, TokenType.QUOTE, TokenType.BROPEN);
            switch (tok.Type)
            {
                case TokenType.TERM:
                case TokenType.QUOTE:
                    ParseTerm(node);
                    break;
                case TokenType.BROPEN:
                    ParseSubClause(node);
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseClause(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Clause), "Clause");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.TERM, TokenType.QUOTE, TokenType.BROPEN);
            switch (tok.Type)
            {
                case TokenType.TERM:
                case TokenType.QUOTE:
                    ParseTerm(node);
                    break;
                case TokenType.BROPEN:
                    ParseSubClause(node);
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseSubClause(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.SubClause), "SubClause");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.BROPEN);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.BROPEN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BROPEN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.OPERATOR);
            while (tok.Type == TokenType.OPERATOR)
            {
                tok = scanner.Scan(TokenType.OPERATOR);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.OPERATOR) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OPERATOR.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }
            tok = scanner.LookAhead(TokenType.OPERATOR);
            }

            
            tok = scanner.LookAhead(TokenType.OPERATOR, TokenType.MUSTPREFIX, TokenType.MUSTNOTPREFIX, TokenType.TERM, TokenType.QUOTE, TokenType.BROPEN);
            while (tok.Type == TokenType.OPERATOR
                || tok.Type == TokenType.MUSTPREFIX
                || tok.Type == TokenType.MUSTNOTPREFIX
                || tok.Type == TokenType.TERM
                || tok.Type == TokenType.QUOTE
                || tok.Type == TokenType.BROPEN)
            {
                ParseExpression(node);
            tok = scanner.LookAhead(TokenType.OPERATOR, TokenType.MUSTPREFIX, TokenType.MUSTNOTPREFIX, TokenType.TERM, TokenType.QUOTE, TokenType.BROPEN);
            }

            
            tok = scanner.LookAhead(TokenType.OPERATOR);
            while (tok.Type == TokenType.OPERATOR)
            {
                tok = scanner.Scan(TokenType.OPERATOR);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.OPERATOR) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OPERATOR.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }
            tok = scanner.LookAhead(TokenType.OPERATOR);
            }

            
            tok = scanner.Scan(TokenType.BRCLOSE);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.BRCLOSE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRCLOSE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseTerm(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Term), "Term");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.TERM, TokenType.QUOTE);
            switch (tok.Type)
            {
                case TokenType.TERM:
                    tok = scanner.LookAhead(TokenType.TERM);
                    if (tok.Type == TokenType.TERM)
                    {
                        tok = scanner.Scan(TokenType.TERM);
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.TERM) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TERM.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                            return;
                        }
                    }
                    break;
                case TokenType.QUOTE:

                    
                    tok = scanner.Scan(TokenType.QUOTE);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.QUOTE) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.QUOTE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }

                    
                    tok = scanner.LookAhead(TokenType.QUOTEDTERM);
                    if (tok.Type == TokenType.QUOTEDTERM)
                    {
                        tok = scanner.Scan(TokenType.QUOTEDTERM);
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.QUOTEDTERM) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.QUOTEDTERM.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                            return;
                        }
                    }

                    
                    tok = scanner.Scan(TokenType.QUOTE);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.QUOTE) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.QUOTE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            }

            parent.Token.UpdateRange(node.Token);
        }


    }

    #endregion Parser
}
